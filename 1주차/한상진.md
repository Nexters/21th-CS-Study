### 📕 프로세스(Process)란?

<img src = "https://gmlwjd9405.github.io/images/os-process-and-thread/process.png" width = "50%">

- 프로세스는 사전적으로 "컴퓨터에서 연속적으로 실행되고 있는 컴퓨터 프로그램"으로 해석할 수 있으며, 메모리에 올라와 실행되고 있는 프로그램의 인스턴스(독립적인 객체)이다.
- 쉽게 말해, 운영체제로부터 시스템 자원을 할당받아 실행된 프로그램을 의미한다.
- 프로세스는 각각 독립된 메모리 영역(Code, Data, Stack, Heap)을 할당 받는다.
- 기본적으로 프로세스당 최소 1개의 스레드(메인 스레드)를 갖고 있다.
- 각 프로세스는 별도의 주소 공간에서 실행되며, 한 프로세스는 다른 프로세스의 변수나 자료구조에 접근할 수 없다.
- 한 프로세스가 다른 프로세스의 자원에 접근 하려면 프로세스 간의 통신(IPC)을 사용해야한다. (ex. 파이프, 파일, 소켓 등을 이용한 통신 방법)

<br>

<hr>

<br>

### 📕 스레드(Thread)란?

<img src = "https://gmlwjd9405.github.io/images/os-process-and-thread/thread.png" width = "50%">

- 스레드는 사전적으로 "프로세스 내에서 실행되는 여러 흐름의 단위"로 해석할 수 있으며, 프로세스의 특정한 수행 경로를 뜻한다.
- 쉽게 말해, 프로세스가 할당받은 자원을 이용하는 실행의 단위를 의미한다.
- 스레드는 프로세스 내에서 각각 Stack만 따로 할당받고, Code, Data, Heap 영역은 공유한다.
- 스레드는 한 프로세스 내에서 동작되는 여러 실행의 흐름으로, 프레세스 내의 주소 공간이나 자원들(힙 공간 등)을 같은 프로세스 내에 스레드끼리 공유하면서 실행된다.

<br>

**스레드마다 스택을 독립적으로 할당하는 이유**

스택은 함수 호출시 전달되는 인자, 되돌아갈 주소값, 함수 내에서 선언하는 변수 등을 저장하기 위해 사용되는 메모리 공간이므로, 독립적인 실행 흐름을 추가하기 위해 최소 조건으로 독립된 스택을 할당한다.

<br>

<hr>

<br>

### 📕 멀티 프로세스

- 멀티 프로세싱이란, 하나의 응용 프로그램을 여러 개의 프로세스로 구성하여 각 프로세스가 하나의 작업을 처리하도록 하는 것이다.

|구분|내용|
|:--------:|:--------:|
|**장점**|여러 개의 자식 프로세스 중 하나에 문제가 발생해도 다른 영향이 확산되지 않는다.|
|**단점**|프로세스 사이의 어렵고 복잡한 통신 기법(IPC) <br> Context Switching에서의 오버헤드|

<br>

### 📕 멀티 스레드

- 멀티 스레딩이란, 하나의 응용 프로그램을 여러 개의 스레드로 구성하고 각 스레드로 하여금 하나의 작업을 처리하도록 하는 것이다.

|구분|내용|
|:--------:|:--------:|
|**장점**|시스템 자원 소모 감소(자원의 효율성 증대) <br> 시스템 처리량 증가 (처리 비용 감소) <br> 간단한 통신 방법으로 인한 프로그램 응답 시간 단축|
|**단점**|하나의 스레드에 문제가 발생하면 전체 프로세스가 영향을 받는다.<br> 단일 프로세스 시스템의 경우 효과를 기대하기 어려움 <br> 다른 프로세스에서 스레드를 제어할 수 없다. <br> 자원 공유의 문제가 발생한다 (동기화 문제)|

<br>

### 📕 멀티 프로세스 대신 멀티 스레드를 사용하는 이유

<img src = "https://gmlwjd9405.github.io/images/os-process-and-thread/multi-thread.png" width = "70%">

**📌 자원의 효율성 증대**

- 멀티 프로세스로 실행되는 작업을 멀티 스레드로 실행할 경우, 프로세스를 생성하며 자원을 할당하는 시스템 콜이 줄어들어 자원을 효율적으로 관리할 수 있음

**📌 응답 시간 단축 및 처리 비용 감소**

- Context Switching시 스레드는 Stack 영역만 처리하기 때문에 프로세스 간의 전환 속도보다 스레드 간의 전환 속도가 빠르다.

**⚠ 주의할 점**

- 동기화 문제
- 스레드 간의 자원 공유는 전역 변수를 이용하므로 함께 상용할 때 충돌이 발생할 수 있다.


<br>

<hr>

<br>

### 📕 스케줄러

**프로세스를 스케줄링 하기 위한 Queue**에는 세 가지 종류가 존재한다.

📌 Scheduling Queues

- Job Queue : 시스템 안의 모든 프로세스의 집합
- Ready Queue : ready 상태의 메인 메모리 안에 상주하는 모든 프레세스의 집합
- Device Queue : I/O장치 사용을 대기하는 프로세스들의 집합

각각의 Queue에 프로세스들을 넣고 빼주는 스케줄러에도 크게 세 가지 종류가 존재한다.

📌 스케줄러의 종류

- 장기 스케줄러(Long-term scheduler)/잡 스케줄러(Job scheduler)
  - 디스크와 메모리 사이의 스케줄링 담당
  - 어떤 프로세스에 메모리를 할당하여 ready queue로 보낼지 결정하는 역할
- 단기 스케줄러(Short-term scheduler)/CPU 스케줄러(CPU scheduler)
  - 메모리와 CPU 사이의 스케줄링 담당
  - 어떤 프로세스를 running 상태로 전환 시킬지 결정하는 역할
- 중기 스케줄러(Mid-term scheduler)/스와퍼(Swapper)
  - 여유 공간을 마련하기 위해 프로세스를 통째로 메모리에서 디스크로 쫓아내는 역할(swap in/swap out)


<br>

<hr>

<br>

### 📕 CPU 스케줄러

스케줄링 대상은 Ready Queue에 있는 프로세스들이다.

📌 FCFS(First Come First Served)
- 비선점형 스케줄링 방식
- 먼저 도착한 프로세스가 CPU를 먼저 할당.
- 큐를 이용해 쉽게 구현 가능
- ⚠ 콘보이 현상(Convoy Effect) 발생 가능
    - burst time이 긴 프로세스가 먼저 도착해 다른 프로세스의 실행 시간이 전부 늦춰져 효율을 떨어뜨리는 현상

📌 SJF(Shortest Job First)
- 비선점형 스케줄링 방식
- burst time이 짧은 프로세스가 먼저 CPU를 할당
- ⚠ 기아 현상(Starvation) 발생 가능
  - 계속해서 우선순위가 높은 프로세스(burst time이 짧은)가 먼저 실행되어 먼저 도착했어도 우선순위가 낮은 프로세스(burst time이 긴)가 계속해서 CPU를 할당받지 못하는 현상

📌 SRTF(Shortest Remaining Time First)
- 선점형 스케줄링 방식
- 남은 burst time이 더 짧은 프로세스에 CPU를 할당
- 기아 현상 발생 가능

📌 우선순위 스케줄링(Priority Scheduling)
- 선점과 비선점 두가지 방식에 모두 적용 가능
- 우선순위가 높은 프로세스에 CPU를 먼저 할당
- 기아 현상과 무기한 봉쇄가 발생할 수 있으며 에이징 기법을 통해 해결
  - ⚠ 무기한 봉쇄(Indefinite blocking) : 실행 준비는 되어있으나 CPU를 사용못하는 프로세스를 CPU가 무기한 대기하는 상태
  - ⚠ 에이징 기법(Aging) : 먼저 도착한 프로세스가 나이를 계속 먹으며 우선순위가 올라가는 기법

📌 라운드 로빈(RR, Round Robin)
- 선점형 스케줄링 방식, 현대적인 CPU 스케줄링
- 프로세스에 동일한 할당 시간(Time Quantum)만큼 순서대로 계속 CPU를 할당
- 응답시간이 빠르며, 모든 프로세스가 공정하게 CPU를 할당받을 수 있음을 보장
- ⚠ 단, CPU 할당 시간(Time Quantum)이 길 경우, FCFS랑 같아지며 반대로 짧을 경우 잦은 Context Switching으로 오버헤드가 발생한다.<br>　　그렇기 때문에 적당한 CPU 할당 시간을 설정하는 것이 중요하다.

<br>

<hr>

<br>

이미지 출처 : [Link](https://gmlwjd9405.github.io/2018/09/14/process-vs-thread.html)

프로세스/스레드 내용 출처 : [Link](https://gmlwjd9405.github.io/2018/09/14/process-vs-thread.html)

스케줄러 내용 출처 : [Link](https://dheldh77.tistory.com/entry/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%9F%ACScheduler)
